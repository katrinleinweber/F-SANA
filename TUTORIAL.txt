This text file is formatted assuming 128-column terminal width.

SANA stands for Simulated Annealing Network Aligner.  It is meant to align two biological networks, usually PPI networks.

You first need to understand the "holes and pegs" analogy.  You've heard of the old board game "Battleship"?
In that game, there are holes in the board, and pegs that can be placed into the holes.  That's what network alignment is like.
The bigger network is a set of holes (representing nodes), and there are lines painted on the board between various holes, representing edges.

The smaller networks are the pegs. There are "laser beams" between some of the pegs, representing edges between the nodes.
The goal is to place every peg into exactly one hole, in a way that maximizes the number of laser beams that are aligned
to painted edges on the board.  This measure of paired edges is more formally known as EC or S3, but for the analogy you can just think of it as matching edges.

SANA works by starting with all the pegs randomly placed into holes.  Then, it moves pegs around millions of times per
second, trying to maximize the matched edges.  Using simulated annealing, it initially accepts all moves, even bad ones.
This allows it to avoid local maxima. As the anneal progresses, SANA gets more and more picky about which moves to
accept; near the end of the anneal, it *only* accepts good moves, because we assume by that point it's avoided most of
the "bad" local maxima and is now heading towards a pretty good maximum close to the global mamixum. That's the basic idea.

The input networks have binary edges (no weights on the edges). They can be a LEDA (.gw) format, or edge list format.

The output is a 1-to-1 mapping of nodes in the smaller network (in number of nodes) G1 to nodes in the larger G2.
In other words, the output tells us which peg is in which hole, for all the pegs.

We have 3 output files:

    sana.align (the alignment as a 2-column file).
    sana.localMeasures: similar to sana.align but also has the local scores of aligned nodes.
	(MAGNA calls these NCF- node cost functions)
    sana.out (the first line is the alignment in internal format, often a very long line) followed by some statistics.

Networks are assumed to be in the "networks" directory, but this can be bypassed using the -fN arguments (see below).
However, even if you bypass the "networks" directory initially, SANA will *create* a corresponding entry in the networks directrory and use it going forward.  Be careful, this has the side effect that if you change the -fN network, SANA will ignore it in favor of the network in the networks directory.  (This is arguably a bug.)

The reason SANA creates a "networks/yourNetwork" directory is that it will store some information in "networks/yourNetwork/autogenerated"; you need to remove this directory if you change the networks, then SANA will recompute stuff in that directory.

SANA is a random search algorithm.  It (almost always) starts with a random alignment, and then improves it using simulated annealing.  It always requires some time to converge; the longer you give it, the better the solution tends to be.  We recommend 3 minutes minumum (the default is 5), but we've also run it for as long as a week.  It currently uses a single core, but 5 minutes is often enough to get better scoring alignments than any other algorithm can do in any amount of time.

The simplest possible command line of SANA must specify the two networks:

    ./sana -g1 RNorvegicus -g2 SPombe

This will align rat with S. pombe (the two smallest networks we provide), using s3 (symmetric substructure score) as the scoring function to guide the aligment, a 5 minute run time, and produce sana.out, sana.align, and sana.localMeasures.  Copious output will go to the screen telling you what's happening.  The run will take about 6 minutes because there's about 1 minute of pre-processing that occurs, including estimating the optimal temperature schedule for the anneal before we even start the anneal.

The above command line, since it uses s3 by default as the objective, allows direct comparison with MAGNA, since MAGNA uses s3 by default as its topological measure.

Say you want to do the above, but run SANA for an hour instead of 5 minutes.  Then specify runtime in minutes using "-t":

    ./sana -g1 RNorvegicus -g2 SPombe -t 60

SANA HAS MANY, MANY OPTIONS
Say you want to specify the networks in edge-list format, and they're not in the networks directory. Use the "-f" format:

    ./sana -fg1 ../../some-path/Network1.el  -fg2 ../some-other-path/Network2.el

Remember than SANA will create entries for these networks in the networks directory: networks/Network1/Network1.gw, and 
the same for Network2.  (Yes, it'll store the files in LEDA.gw format even though you gave it edge-list as input. Again,
this can be bad and is arguably a bug.)

Say you want to use EC rather than S3.  All the objective functions SANA can use are specified on the command line using weights (which will be normalized to sum to 1 if they don't). s3 by default has a weight of 1, so we'd need to turn it off first:

    ./sana -s3 0 -ec 1 {and then specify your two networks}

Say you're happy with s3 but want to add in graphlets as defined in the original GRAAL paper:

    ./sana -graphlets 0.5 -s3 0.5 {then specify your two networks}

Say you prefer graphlets as L-GRAAL defined them:

    ./sana -graphletlgraal 0.5 -s3 0.5 {network-spec}

or if you want to use LGRAAL graphlets alone:

    ./sana -graphletlgraal 1 -s3 0 {network spec}

Be sure always to turn off s3 if you want to, because it's always on (with default weight 1) by default.

L-GRAAL redefined how to use graphlets, but it actually didn't use the graphlets directly to optimize the alignment; instead,
it defined a WEIGHTED EDCE COSERVATION (WEC), and when aligning two pairs of nodes (basically aligning an edge in one network
to an edge in the other), it defined the WEC as the average graphletlgraal similarity of the two endpoints. To do this in SANA you can do the following:

    ./sana -s3 0 -objfuntype generic -topomeasure wec -wecnodesim graphletlgraal -wec 1

Breaking down the above command line:

    -s3 0: turn off s3
    -objfuntype generic: there can be other types of objective functions (see "sana -h")
    -topomeasure wec: define the topological measure of the generic objective function as a WEC
    -wecnodesim graphletlgraal: deine graphletlgraal as the node similarity to use in computing WEC
    -wec 1: actually turn on wec, with weight 1, as an objective (because we turned off s3 above)

The above command line allows direct comparison with L-GRAAL (but of course you need to specify the two networks with -g1 -g2 or -fg1 -fg2, as always).

HubAlign defined a measure called importance; SANA supports that too.  Direct comparison with HubAlign is as follows:

    ./sana -s3 0.002 -importance 0.998 {networkSpec}

We need to turn on a *little bit* of s3 (or EC) in order to force SANA to create a connected alignment, because importance doesn't do that.  See the discussion near the end of the SANA paper for an explanation why.

WAVE (Milenkovic lab) I beleave was actually the first aligner to use esims (by default they use GRAAL-type graphlets) and WEC; we can run a direct comparison against WAVE as follows:

    ./sana -s3 0 -wec 1 -wavenodesim nodec -wecnodesim graphlet

Say you have your own fancy node cost fuction (NCF) that SANA doesn't support. No problem, create a 3-column text file that
defines your sim matrix.  The file has the form

    nodeNameFromG1	nodeNameFromG2	simiralityValue

so for example the first few lines may be
    POP1	USR52	0.456
    URF12	PAP24	0.1053530
    ...etc...

Then run:

    ./sana -s3 0 -g1 DMelanogaster -g2 HSapiens -esim 1 -simFile your-sim-file -simFormat 1

See ./sana -h for help on simFormat options.

Of course frequently you may want to include sequence in your scoring function.  We assume sequences are in the "sequence/scores" directory, with name G1_G2_blast.out, where G1 and G2 are the names from the networks directory.  Then you can do, for example:

   ./sana -s3 0.4 -ec 0.6 -sequence 1

The above will have the score weights sum to 2, which will then be normalized to weights s3 0.2, ec 0.3, sequence 0.5.

There are many more objective functions; just type

    ./sana -h | less

to see *all* of SANA's command-line options

Now say you want to analyze an existing alignment.  You need to create a 2-column alignment file, preferably using the names of the nodes that appear in the networks directory (or the names used in the edge list input file).  Then:

    ./sana -mode analysis -g1 RNorvegicus -g2 SPombe -alignFile YourAlignFile.align -alignFormat 3

alignFormat can be:

    1: sana.out format
    2: aligned pairs format [needs all pegs to be listed as in a hole, using names of proteins]
    3: partial aligned pairs format [some pegs may be missing and will be randomly aligned to empty holes]
    4: partial edge list format using numbers from the LEDA file format instead of names

You can of course evaluate an existing alignment using your own NCF by combining "-mode analysis" with a -esim specification.

-------------------------------------------------------------------

So, now on to some of SANA more esoteric options.

Say there are some pegs that you *know* which hole they're supposed to go into.  That is, there are some pairs of nodes that you know should be aligned.  We call this "locking".  All you need to do is create a 2-column alignment file that list the pairs you want locked into position, and run:

    ./sana -lock youLockedPairsFile.align .... rest of options ...

and voila, those pairs will never move.

Say your nodes have 2 different types; rather than a PPI network, it might be a network that relates GENES to micro-RNAs.
When you align two such networks, you want to align genes to genes, and micro-RNAs to micro-RNAs, and never mix the two.
In that case both your input networks MUST be specified as an edge list, with one column being genes, and the other column being micro-RNAs, and the columns must mean the same thing in the two networks.  Then you tell SANA that the edge list columns have
meaning:

    ./sana -fg1 G1.el -fg2 G2.el -nodes-have-types

The "-nodes-have-types" options essentially locks the types together. REMEMBER: that SANA will *create* entries in the
networks directory for these networks, and the format of the files in the networks directory are LEDA.gw, which *loses the type information*!!! (Yes, this is definitely a bug.)  It is thus safest to remove the networks/G1 and networks/G2 directories entirely, each time you restart a -nodes-have-types run.  This is definitely an inconvenience (read "bug"), and we will fix it in the future.

Of course you may know in some cases which genes
in the two species should be aligned; then just lock them:

    ./sana -fg1 G1.el -fg2 G2.el -nodes-have-types -lock geneLockFile.align

Sometimes you know what the entire true alignment should be, and you're just testing SANA: use the "-truealignment" to tell SANA to compare its generated alignment at the end, with the true alignment.  If you specify this then you can also tell SANA to
use the correct alignment as an objective function usung "-s3 0 -nc 1" (NC="node correctness"). This is almost useless except to show that SANA can very quickly convere to the correct answer, when given the correct answer as an objective.  Surprisingly, many algorithms can't produce the correct answer even if it's given to them as an objective function.

SANA has still more features; for example it can interact automaticaly with SGE to run a pre-defined sequence of experiments on a cluster, and analyze the results.  But that'll have to wait for a longer documentation file.  The "doc" directory contains more info.

-----------------------------------

WRAPPING OTHER ALGORITHMS

Finally, to facilitate direct comparisons with other aligners, we actually include the source and executables for about
a dozen other aligners.  And even more than that... we can call them directly from the SANA command line.  This allows
us to never worry about whether we've called the other aligner correctly, because SANA will translate its own command
line into the appropriate call to the other algorithm.  We call this "wrapping" the algorithm, and you can see which
algorithms we have wrapped by looking in the "wrappedAlgorithms" directory.  The source (in C++) for the wrappers
themselves are are in the src/methods/wrappers directory.

You can specify another algorithm using the "-method" argument to SANA.  So for example if you want to run MAGNA
inside of SANA, you can do:

    ./sana -method magna {network-pair-spec}

This will run MAGNA optimizing s3, as it does by default.  If there is an argument you want to pass to the wrapped
algorithm and no such argument exists in SANA, then use the "-wrappedArgs" argument, like this:

    ./sana -method magna -s3 0.2 -sequence 0.7 -wrappedArgs "-d sequence/bitscores/${G1}_${G2}.bitscores -a 0.2 -t 4"

(The -t option to MAGNA tells it to use 4 threads).

We have wrappers for the following algorithms, although not all of them are as well implementet as others:

CytoGEDEVO  GHOST  HGRAAL    LGRAAL   MI-GRAAL  NATALIE  OptNetAlign  PISWAP  WAVE
GEDEVO      GREAT  HubAlign  MAGNA++  multi     NETAL    PINALOG      SPINAL

